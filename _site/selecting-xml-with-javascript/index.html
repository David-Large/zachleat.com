<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Selecting XML Nodes with JavaScript (Peril <span class="widow">of getElementsByTagName)</span>—zachleat.com</title>
		<link href="/atom.xml" rel="alternate" title="Web 367 via zachleat.com" type="application/atom+xml">

		<link href="/web/css/global.css" rel="stylesheet">
	</head>
	<body>
		<div class="rail">
			<header>
				<a href="/web/">
					<h1>Web 3.0, 6 Bladed Razors, 7 Minute Abs</h1>
				</a>
				<h2>A bunch of words by zachleat.</h2>
			</header>
			<aside>
				<nav role="navigation">
				</nav>
			</aside>
		</div>
		<div class="content">
			<div class="main" data-role="main">
				<article>
<h1>Selecting XML Nodes with JavaScript (Peril <span class="widow">of getElementsByTagName)</span></h1>
<em>Posted on 10 May 2008</em>
<h1></h1>

<p><em>There are two popular camps for ajax data formats right now: XML and JSON. Both have their (dis-)advantages. The purpose of this article is to show you how to effectively parse XML in the browser.</em></p>

<h3>Super Fast Beginner’s Primer</h3>

<ul>
<li>Case 1: <strong>Node</strong> (or un-namespaced node, null-namespaced node): a node without a prefix, such as child here:<br/>
``</li>
<li>Case 2: <strong>Default namespaced node</strong>: a node without a prefix, but a parent node (or itself) has a xmlns attribute, like both root and child here:<br/>
``</li>
<li>Case 3: <strong>Namespaced node</strong>: a node with a prefix, and a parent node (or itself) declaring a xmlns with that prefix attached, like both child and root here:<br/>
``</li>
</ul>


<h3>/End Primer</h3>

<p>Parsing XML in the browser can be a tricky beast. There are many different wrong ways to do it, which can leave you cold and naked in a snowstorm if you’re not careful. So, let’s put on the metaphorical electric one-sie of standards based code and let the power of Edison heat our JavaScript code like the innards of a <a href="http://starwars.wikia.com/wiki/Tauntaun">tauntaun</a>.</p>

<p>If there is one thing you can take away from this article, its that the problems with XML in JavaScript have already been solved, and there is library code out there to do the job for you. But libraries aren’t a substitute for knowledge (abstraction is a dangerous thing during education), so let’s learn <strong>why</strong> these problems are occurring so we can wrinkle our gray matter and increase our productivity at the same time.</p>

<h2>Use Cases</h2>

<p>These are the main use cases that takes place when selecting a node inside of an XML document:</p>

<ol>
<li><p><strong>Case 1</strong>: Selecting un-namespaced nodes (or nodes in the null namespace):</p>

<p>This one is easy. If you can guarantee that your XML will never have any namespaces, you’re home free. Take your get out of jail free card and run for the hills. Using this assumption, you can query nodes inside of your XML Document object using nothing other than <code>getElementsByTagName()</code>. Lucky bastard.</p>

<pre><code>// assume oDocEl is the documentElement inside of an XML Document 
var correctForCase1 = oDocEl.getElementsByTagName&amp;#40;'child'&amp;#41;;
</code></pre></li>
<li><p><strong>Case 2</strong>: Selecting default namespaced nodes:</p>

<p>Tread lightly, this is about to get serious. In most cases, historically I had thought that using the solution described for Case 1 would be sufficient in this case. I had learned awhile back that Internet Explorer treats node names (including namespace prefix and local name together) as one string. So, the method for Case 1 should work for Internet Explorer, especially in the case of node sans prefix. In Firefox, you’d have to use getElementsByTagNS(), but that would be just a simple wrapper.</p>

<p>Then I met an Internet Explorer exception. The only unique thing about this installation of Internet Explorer 7 was that it had MSXML 6 installed, when all the other computers I had tested on were using MSXML 3. The obvious conclusion here is that MSXML 6 won’t select child nodes for Case 2.</p>

<pre><code>var incorrectForCase2 = oDocEl.getElementsByTagName&amp;#40;'child'&amp;#41;;
</code></pre>

<p>Here’s the right way to select nodes for Case 2. Fair warning, to keep the code examples here simple, this solution requires Sarissa (sarissa.js and sarissa_ieemu_xpath.js) to be included on the page prior to usage.</p>

<pre><code>// assume oDoc is an XML Document object.
oDoc.setProperty&amp;#40;"SelectionNamespaces", "xmlns:whatever='http://example.com/'"&amp;#41;;
var oDocEl = oDoc.documentElement;
var correctForCase2A = oDocEl.selectNodes&amp;#40;'whatever:child'&amp;#41;;
var correctForCase2B = oDocEl.selectSingleNode&amp;#40;'whatever:child'&amp;#41;;
</code></pre>

<p>Note how we’ve mapped what was the default namespace (without a prefix) to be a namespace WITH a prefix during the node selection.</p>

<p>It should be noted that when the resultant XML has a namespace attached (Case 2 and 3), Firefox works fine using getElementsByTagNameNS. IE doesn’t include support for that method, however, so we’re forced to find a more complete solution.</p>

<ul>
<li><p><strong>Case 3</strong>: Select a non-default namespaced node:</p>

<p>As I mentioned in Case 2, normally (pre-MSXML 6), you’d be able to perform a <code>getElementsByTagName('prefix:child')</code> in IE and use getElementsByTagNameNS in Firefox as usual. But that has changed now. We need to set up the SelectionNamespaces property for IE, and we’ll use Sarissa to take it cross-browser for us.</p>

<pre><code>// assume oDoc is an XML Document object.
oDoc.setProperty&amp;#40;"SelectionNamespaces", "xmlns:whatever='http://example.com/'"&amp;#41;;
var oDocEl = oDoc.documentElement;
var correctForCase3A = oDocEl.selectNodes&amp;#40;'whatever:child'&amp;#41;;
var correctForCase3B = oDocEl.selectSingleNode&amp;#40;'whatever:child'&amp;#41;;
// Note, this is the same code as Case 2 (which is a good thing)
</code></pre>

Note that we did <em>not</em> have to use the same prefix that was defined by the result XML. We can map it to whatever we want (literally).

<h2>Why is this important?</h2>

<p>Because most libraries don’t handle Case 2 and Case 3, which are important parts of XML. Here’s some code straight from YUI 2.5.1 (DataSource component):</p>

<pre><code>// Line 1394
var xmlNode = result.getElementsByTagName&amp;#40;key&amp;#41;;
if&amp;#40;xmlNode &amp;&amp; xmlNode.item&amp;#40;&amp;#41; &amp;&amp; xmlNode.item&amp;#40;&amp;#41;.firstChild&amp;#41; &amp;#123;
    data = xmlNode.item&amp;#40;&amp;#41;.firstChild.nodeValue;
&amp;#125;
else &amp;#123;
       data = "";
&amp;#125;
</code></pre>

<p>Notice how they just do getElementsByTagName. For shame :( jQuery doesn’t handle Case 2 or Case 3 either. (Proof is an exercise to the reader :P) So, if you have XML data sources with namespaces, it would do you well to use the solution presented in this article, or you’re going to have headaches later.</p>

<h2>Springer’s Final Word</h2>

<p>Don’t use getElementsByTagName. If you do, PLEASE include a note saying that your code isn’t going to support namespaced XML. Branch your selection code to check if Sarissa has been included on the page, and use Sarissa for namespaced XML if it’s there. It’s not fun to be pidgin-holed into the simplest case of XML.</p></li>
</ul>
</li>
</ol>


</article>
			</div><!-- /.main -->
		</div><!-- /.content -->
		<script type="text/javascript">
		// var _gaq = _gaq || [];
		// _gaq.push(['_setAccount', '']);
		// _gaq.push(['_trackPageview']);

		// (function() {
		// 	var ga = document.createElement('script');
		// 	ga.type = 'text/javascript';
		// 	ga.async = true;
		// 	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		// 	var s = document.getElementsByTagName('script')[0];
		// 	s.parentNode.insertBefore(ga, s);
		// })();
		</script>
	</body>
</html>