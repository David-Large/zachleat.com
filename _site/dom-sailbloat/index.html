<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Maiden Voyage of the <span class="widow">DOM Sailbloat</span>—zachleat.com</title>
		<link href="/atom.xml" rel="alternate" title="Web 367 via zachleat.com" type="application/atom+xml">

		<link href="/web/css/global.css" rel="stylesheet">
	</head>
	<body>
		<div class="rail">
			<header>
				<a href="/web/">
					<h1>Web 3.0, 6 Bladed Razors, 7 Minute Abs</h1>
				</a>
				<h2>A bunch of words by zachleat.</h2>
			</header>
			<aside>
				<nav role="navigation">
				</nav>
			</aside>
		</div>
		<div class="content">
			<div class="main" data-role="main">
				<article>
<h1>Maiden Voyage of the <span class="widow">DOM Sailbloat</span></h1>
<em>Posted on 19 Jul 2010</em>
<h1></h1>

<p><img src="http://www.zachleat.com/web/wp-content/uploads/2010/07/typhoon-in-macao.jpg" title="typhoon-in-macao" alt="" /></p>

<p>As many of you may already know, my day job includes managing a large and complex enterprise jQuery-based user interface component library. It’s used by all new web applications at the company, which boasts over an IT department of approximately 1500 people and hundreds of web applications. Needless to say, I get a fair volume of interesting support tickets that come my way. A few weeks ago, I had the pleasure of receiving one such ticket.</p>

<p>The support ticket’s symptoms included a oft-heard complaint: poor performance. On the web, poor performance can be attributed to a great many things, but most often can be boiled down to a bottleneck in JavaScript code using the DOM API. This time, strangely enough, the culprit was something else entirely.</p>

<p>One of the first things I check when an application complains of poor performance is the total size of the document, or how many nodes it has. One of the best ways to ensure good performance is to keep your document small, especially on projects using heavy dynamic element selection and filtering (think jQuery, Mootools, Prototype, Dojo, or any code using a selector engine like Sizzle). Any JavaScript library emulating CSS selectors executing over a very large document is going to take quite a bit longer than querying a small document, especially when the user’s browser doesn’t support native <code>querySelector</code> or <code>getElementsByClassName</code>.</p>

<p>To get an idea of what the size of a large document is, I usually go to a site with some fairly advanced JavaScript and query their size.</p>

<pre><code>// Returns the total number of nodes in the document
document.getElementsByTagName('*').length;
// note: this number will not include any child nodes inside of iframes.
</code></pre>

<p>URL</p>

<p>Total Element Count</p>

<p><code>maps.google.com</code></p>

<p><code>731</code></p>

<p><code>my.yahoo.com</code></p>

<p><code>1508</code></p>

<p><code>calendar.google.com (Authenticated)</code></p>

<p><code>681</code></p>

<p><code>reader.google.com (Authenticated)</code></p>

<p><code>4866</code></p>

<p>Getting back to the support ticket in question. After querying the document, I quickly found that the page contained over <strong>50000 nodes</strong>. Wow. So, we’ve caught a big one. You’re going to be telling your grandkids about this some day. But, now what?</p>

<p>I decided it would be beneficial to find out where and what all of those nodes were. After clicking around the live document in the Firebug’s HTML tab for awhile, looking at View Source, and Ajax requests in the Console, I successfully determined the culprit. This particular application was using <a href="http://wicket.apache.org/">Wicket</a>, a popular Java library for web applications, which includes its own <em>Ajax Logger</em> component (similar to my favorite <a href="http://log4javascript.org/">log4javascript</a>; or something like the <a href="http://developer.yahoo.com/yui/logger/">YUI Logger</a>), used to keep track of an application’s Ajax calls and JavaScript page manipulations with an inline GUI embedded in the parent document. On one page load, this application’s Ajax logger component had <strong>created 40000 nodes of log content</strong>.</p>

<p>It’s important to realize that embedding unnecessary content of that magnitude on the page can be very detrimental to performance. <strong>JavaScript loggers should log to a new child window, rather than be embedded in the parent document.</strong> This way they won’t bloat the document, but still provide you with much needed logging information.</p>

<p>But, in the future, how might this type of problem be more easily diagnosed and prevented? Ideally, when confronted with large documents, we want to see where in the document the majority of those nodes are located. But there isn’t an easy way to see which portion of the document is using the largest number of nodes, especially if the culprit is deep into the document tree. We can go through the source code manually, but that isn’t very efficient.</p>

<p>So in the spirit of exploratory development to help troubleshoot real-world problems, I decided to make a Firebug Lite plugin. This would give me an easy cross-browser tool to diagnose my problem in a familiar interface. Load up Firebug Lite, load the <em>DOM Sailbloat</em> JavaScript file, and easily spot the HTML love handles.</p>

<p>Here’s what it looks like in action:<br/>
<img src="http://www.zachleat.com/web/wp-content/uploads/2010/07/Screen-shot-2010-07-19-at-9.59.49-PM.png" title="Screen shot of the DOM Sailbloat Firebug Lite plugin" alt="" /></p>

<h2>Go Forth</h2>

<ol>
<li><a href="http://www.zachleat.com/domsailbloat/">See the demo</a></li>
<li><a href="http://www.zachleat.com/domsailbloat/domsailbloat.js">Download the source</a></li>
<li><a href="http://github.com/zachleat/DOM-Sailbloat">Fork the Sailbloat on GitHub</a></li>
</ol>


<p><em>Note: there is currently an undiagnosed issue with the Sailbloat and it fails to load intermittently. If you know why, I’d be happy to put your name in the source code credits.</em></p>

</article>
			</div><!-- /.main -->
		</div><!-- /.content -->
		<script type="text/javascript">
		// var _gaq = _gaq || [];
		// _gaq.push(['_setAccount', '']);
		// _gaq.push(['_trackPageview']);

		// (function() {
		// 	var ga = document.createElement('script');
		// 	ga.type = 'text/javascript';
		// 	ga.async = true;
		// 	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		// 	var s = document.getElementsByTagName('script')[0];
		// 	s.parentNode.insertBefore(ga, s);
		// })();
		</script>
	</body>
</html>