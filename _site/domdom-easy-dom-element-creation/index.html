<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>DOMDom, easy DOM <span class="widow">Element Creation</span>—zachleat.com</title>
		<link href="/atom.xml" rel="alternate" title="Web 367 via zachleat.com" type="application/atom+xml">

		<link href="/web/css/global.css" rel="stylesheet">
	</head>
	<body>
		<div class="rail">
			<header>
				<a href="/web/">
					<h1>Web 3.0, 6 Bladed Razors, 7 Minute Abs</h1>
				</a>
				<h2>A bunch of words by zachleat.</h2>
			</header>
			<aside>
				<nav role="navigation">
				</nav>
			</aside>
		</div>
		<div class="content">
			<div class="main" data-role="main">
				<article>
<h1>DOMDom, easy DOM <span class="widow">Element Creation</span></h1>
<em>Posted on 07 Jul 2007</em>
<h1></h1>

<p>Generally when approaching a complex problem involving web programming in JavaScript, the first question I ask myself is ‘What would Jesus do?’ As much as I am entertained by a mental picture of Mr. Jesus himself sitting on his <a href="http://www.geocities.com/ResearchTriangle/Node/4081/">Jesux Distro</a> appending children (and parents) into his DOM, I am instead distracted by an intense “passionate” hatred for Mel Gibson swelling in my chest. It’s actually quite distracting to the problem I am having, but I calm myself by punching my 4 foot tall inflatable Mad Max and wonder how much time I waste doing this. I figure it happens about twice an hour. (Digression)</p>

<p>The DOM. Arch-nemesis of web developers attempting to support the ultimately tiny (I think it’s down to about 5 or 8% now?) sliver of browser market share that Internet Explorer currently entails. Let’s make it easier on ourselves and make a little package to do it for us. Run a function, pass in an argument with a description of the DOM node(s) we wish to create, and have the package auto-correct any bugs we would have encountered during manual creation, and maybe even have it inserted or appended for us.</p>

<p>But wait, why are we doing this when there are literally 80 billion other DOM element creation classes already out there? It’s all about syntax. The existing packages are incredibly verbose, focusing too much on a complex object structure to describe the nodes, in some cases even having separate objects for attributes inside a single node. Why not use the syntax we’ve already come to love in the various DOM query libraries that are available? Why not use DOMDom? Let’s see a few examples:</p>

<p>Single Node String</p>

<pre><code>'div'
</code></pre>

<p>Single Node String with ID and Classes</p>

<pre><code>'div#id1.class1.class2'
</code></pre>

<p>Single Node String for a Form Element</p>

<pre><code>'input[name="myTextBox",type="text",maxlength="5"]'
</code></pre>

<p>Single Node String with Style Syntax</p>

<pre><code>'div{height=80px,color=#f90,border=1px solid #000}'
</code></pre>

<p>Complex Single Node String with ID, multiple classes, Style, and Namespaced Attribute)</p>

<pre><code>'div#id1.class1.class2[style="width:60px;color:#f90",@class="class4",@att="true",@namespace:att="false"]'
</code></pre>

<p>Multiple Node String: Linear (Parents with one Child)</p>

<pre><code>'div span div'
</code></pre>

<p>Multiple Node String: Non-Linear (Parent with more than one Child)</p>

<pre><code>&amp;#123; 'div': &amp;#91; 'span', 'span' &amp;#93; &amp;#125;
</code></pre>

<h1>How Does It Work?</h1>

<p>By default, it’s set up to do HTML Fragments (innerHTML) because they are much speedier than the manual DOM element creation (createElement). But if you desire, you can toggle a boolean in the code and it will switch back to DOM element creation. When in DOM element creation mode, it will account for the following browser bugs:</p>

<ul>
<li>(IE6) Standardized for attribute representation (pointer to htmlFor)</li>
<li>(IE6) Standardized case for accesskey, usemap, maxlength, and frameborder attributes.</li>
<li>(IE6) Standardized checked attribute for radio and checkboxes.</li>
<li>(IE6) Special consideration for dynamic handling of name and type attributes (on form elements).</li>
<li>(Firefox) <a href="http://developer.mozilla.org/en/docs/Whitespace_in_the_DOM">Works with whitespace that is treated as a node.</a></li>
</ul>


<h1>Syntax</h1>

<p>You should already be able to tell how to create a node from the examples above. Here are some more things you might not have guessed:</p>

<p>Creating a node with an id</p>

<pre><code>'div#myId'
</code></pre>

<p>Creating a node with CSS classes</p>

<pre><code>'div.class1.class2'
</code></pre>

<p>Creating two nodes at the same level</p>

<pre><code>&amp;#91; 'div', 'div' &amp;#93;
</code></pre>

<p>Creating a node with two children</p>

<pre><code>&amp;#123; 'div': &amp;#91; 'div', 'div' &amp;#93; &amp;#125;
</code></pre>

<p>You can mix the {} and [] syntax wherever you like, but if you want a node to have non-linear children, you have to use the {} object notation.</p>

<p>Creating a text node (start the node declaration with a #, you can change this to another non-conflicting character in the code if you like)</p>

<pre><code>'#Any Text Here'
</code></pre>

<p>Creating a node with attributes (the @ is optional)</p>

<pre><code>'div[class="class3",style="width:60px;color:#f90",@att="true",@namespace:att="false"]'
</code></pre>

<p>Creating a node with a Style Shortcut (mixing with a style attribute is handled properly)</p>

<pre><code>'div{color=#f90,border=1px solid #000}[style="height:80px;background:#fff"]'
</code></pre>

<p>A few notes on attributes. Quotes are required on attributes (single or double but be consistent), but are not required in the style shortcut declaration. Quotes are not allowed to be nested inside of attributes (a single quote cannot be inside of a double quote and vice versa).</p>

<p>And of course, all of the above can be mixed together</p>

<pre><code>'div#myId.class1.class2{color=#f90}[customAttr="true",@customAttr2="false"] div#child1 div#child2'
</code></pre>

<h1>Usage</h1>

<p><strong>Appending</strong> at the end of a parent’s children:</p>

<pre><code>DOMDom.append&amp;#40; 'div', yourParentNode &amp;#41;;
</code></pre>

<p><strong>Replacing</strong> the children of a parent:</p>

<pre><code>DOMDom.replace&amp;#40; 'div', yourParentNode &amp;#41;;
</code></pre>

<p><strong>Unshifting </strong>(inserting at the beginning of a parent’s children):</p>

<pre><code>DOMDom.unshift&amp;#40; 'div', yourParentNode &amp;#41;;
</code></pre>

<p><strong>Inserting</strong> before a certain integer index of a parent’s children:</p>

<pre><code>DOMDom.insert&amp;#40; 'div', yourParentNode, 2 &amp;#41;; // must have at least 3 children, the index is 0 based, if index is null with unshift by default
</code></pre>

<h1>Templates</h1>

<p>Use  to indicate a variable, in this example</p>

<p>`
// "Compile" the template
var str = DOMDom.compile( { 'div.test span': '#Test ' } );
// Use your template in some context, notice the test variable being set.
for( var j = 0; j &lt; 1000; j   )
{</p>

<pre><code>// knows we're using a compiled template since we're passing in variables as a third argument.
DOMDom.append( str, d, { test: j } );
</code></pre>

<p>}
`</p>

<h3>Benchmarks</h3>

<h4>(If you have Firebug open, make sure it's not on the HTML tab, this will slow down the benchmark significantly)</h4>

<p>Most of my work here has been inspired by the DomQuery and DomHelper classes written by JavaScript rock star Jack Slocum (the guy's initials are J.S. for God's sake), so I modeled my benchmark after <a href="http://www.jackslocum.com/blog/examples/domhelper.php">his benchmark hosted on his website to test the DomHelper class</a>. I'm running the same nodes he's testing on his website, so the results should be comparable. You can <a href="http://www.zachleat.com/Projects/DOMDom/benchmark.html">test my benchmark for DOMDom here</a>. Here are some results, reporting the average of 3 results with the format of an uncompiled element first and the compiled template in square brackets.</p>

<h2>DOMDom Results</h2>

<p>Internet Explorer 6: 666 ms [328 ms]<br/>
Firefox 2.0.0.4: 1880 ms [666 ms]<br/>
Safari 3.0.2 [Windows]: 546 ms [151 ms]<br/>
Opera 9.21: 343 ms [140 ms]</p>

<h2>Comparative numbers from Jack Slocum's DomHelper</h2>

<p>Internet Explorer 6: 2458 ms [677 ms]<br/>
Firefox 2.0.0.4: 672 ms [458 ms]<br/>
Safari 3.0.2 [Windows]: 291 ms [119 ms]<br/>
Opera 9.21: 370 ms [166 ms]</p>

<p>The thing to take away from this is the question of why Satan is haunting my benchmarks? Two 666 averages? Anyway, DOMDom is quite a bit faster in the most popular browser, Internet Explorer, although I haven't tested it on IE7 yet. In Firefox, the opposite is true, with DomHelper taking the lead. Opera is comparable and Safari is faster in DomHelper as well. You can run your own tests using the links above.</p>

<h1>Dependencies</h1>

<p>This library was built to work with Yahoo User Interface (YUI), but could be trivially ported to another library by changing the function dependencies listed in the ADAPTER variable in the code.</p>

<pre><code>var ADAPTER = &amp;#123;
    setStyle: YAHOO.util.Dom.setStyle,
    addClass: YAHOO.util.Dom.addClass,
    isString: YAHOO.lang.isString,
    isArray: YAHOO.lang.isArray,
    isNumber: YAHOO.lang.isNumber,
    isObject: YAHOO.lang.isObject,
    get: YAHOO.util.Dom.get
&amp;#125;; // to port, change these references
</code></pre>

<p>If you're still reading this encyclopedia, here are some links:</p>

<ul>
<li><a href="http://www.zachleat.com/Projects/DOMDom/DOMDom.js">DOWNLOAD DOMDom</a></li>
<li><a href="http://www.zachleat.com/Projects/DOMDom/DOMDom-min-jsmin.js">DOWNLOAD DOMDom Minimized with JSMIN (10KB)</a></li>
<li><a href="http://www.zachleat.com/Projects/DOMDom/DOMDom-min-packer.js">DOWNLOAD DOMDom Minimized with Packer (6KB)</a></li>
<li><a href="http://www.zachleat.com/Projects/DOMDom/benchmark.html">See the benchmark</a></li>
<li><a href="http://www.zachleat.com/Projects/DOMDom/tests.html">See the test file with a bunch of examples of syntax</a></li>
</ul>


<p><a href="http://www.encyclopedia.com/doc/1O27-dom1.html"><em>-dom suffix denoting condition or state, as in freedom, wisdom, or DOMDom</em></a></p>

<p><strong>Update</strong>: changed the variable syntax to allow variables inside of nodes (not just text).</p>

</article>
			</div><!-- /.main -->
		</div><!-- /.content -->
		<script type="text/javascript">
		// var _gaq = _gaq || [];
		// _gaq.push(['_setAccount', '']);
		// _gaq.push(['_trackPageview']);

		// (function() {
		// 	var ga = document.createElement('script');
		// 	ga.type = 'text/javascript';
		// 	ga.async = true;
		// 	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		// 	var s = document.getElementsByTagName('script')[0];
		// 	s.parentNode.insertBefore(ga, s);
		// })();
		</script>
	</body>
</html>